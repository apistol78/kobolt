<?xml version="1.0" encoding="utf-8"?>
<object type="traktor.script.Script" version="2">
	<text>
	<![CDATA[
#using \{720C0A68-B608-2F40-8EBA-F7E42EB27F61}
#using \{F266FE75-7BF7-BC4C-9616-06D2B5F5F6E8}

import(traktor)

Game = Game or class("Game", Stage)

function Game:new(params, environment)
	Stage.new(self, params, environment)

	self._inputMapping = environment.input.inputMapping
	self._lobbyManager = LobbyManager(environment)

	environment.input.inputSystem:setExclusive(true)


	local timer = Timer()
	while timer.elapsedTime < 1 do
		--- wait a second
	end

end

function Game:update(info)

	-- Update systems.
	self._lobbyManager:update()

	-- Use network time.
	local t = self._lobbyManager._time
	self.world.alternateTime = t

	-- Get relevant entities.
	local playerEntity = self.world:getEntity("Player")
	local cameraEntity = self.world:getEntity("Camera")

	-- Get player's character controller.
	local characterComponent = playerEntity:getComponent(physics.CharacterComponent)

	-- Read input state values.
	local deltaHead = self._inputMapping:getStateValue("STATE_HEAD")
	local pitch = self._inputMapping:getStateValue("STATE_PITCH")
	local moveZ = self._inputMapping:getStateValue("MOVE_Z")
	local moveX = self._inputMapping:getStateValue("MOVE_X")
	local jump = self._inputMapping:isStatePressed("STATE_JUMP")

	-- Issue movement of player character.
	local Qhead = Quaternion.fromEulerAngles(characterComponent.headAngle, 0, 0)
	local Vmove = Qhead:transform(Vector4(moveX, 0, moveZ, 0))

	characterComponent.headAngle = characterComponent.headAngle + deltaHead * 0.01
	characterComponent:move(Vmove, false)

	if jump then 
		print("jump")
		characterComponent:jump()
	end

	-- Update camera transform to follow player.
	local T = playerEntity.transform
	cameraEntity.transform = T * Transform(
		Vector4(0, 1.85, 0),
		Quaternion.identity
	) * Transform(
		Vector4(0, 0, 0),
		Quaternion.fromEulerAngles(0, pitch, 0)
	)


	if self._lobbyManager._replicator ~= nil then

		local replicator = self._lobbyManager._replicator

		-- Use camera origin for replication origin.
		replicator:setOrigin(cameraEntity.transform)
		replicator:setSendState(true)

		-- Pack player state.
		local state = jungle.State()
		state:packBegin()
		state:pack(jungle.TransformValue(playerEntity.transform))
		replicator.state = state


		local ghostEntity = self.world:getEntity("Ghost")

		if replicator.proxyCount >= 1 then
			local proxy = replicator:getProxy(0)
			if proxy.connected then

				if not proxy.latencyReliable then
					print("not reliable yet")
				end

				if proxy.stateTemplate == nil then
					print("ghost template create")
					local stateTemplate = jungle.StateTemplate()
					stateTemplate:declare(jungle.TransformTemplate("Transform"))
					proxy.stateTemplate = stateTemplate
					proxy:setSendState(true)
				else

					local localState = jungle.State()
					localState:packBegin()
					localState:pack(jungle.TransformValue(ghostEntity.transform))

					local state = proxy:getFilteredState(t, 0.2, localState, 0.7)
					if state ~= nil then

						state:unpackBegin()
						local Tghost = state:unpack():get()
						ghostEntity.transform = Tghost

						proxy.origin = Tghost.translation
					end
				end
			end
		end
	end
end

	]]>
	</text>
</object>
